题目：

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 

解题思路：

1.当一个问题具有重叠子问题（大问题分解为若干个子问题，这些子问题会重复出现）和最优子结构（一个问题的最优解可以由其子问题的最优解有效地构建出来）时，可以使用动态规划来解决。

2.动态规划最关键的两点是确定状态边界和状态转移方程。

3.该问题可以转化为使用dp[i]保存以array[i]作为末尾的连续序列的最大和，（强制要求以array[i]结尾）当i为0时，序列长度为1，此时和即为第一个元素的值，确定了边界条件；当i往后遍历时，我们只考虑i-1对i的影响，取max(array[i],array[i]+dp[i-1])即可。

代码：

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if(array.size()==0)
            return 0;
        vector<int> dp;
        //dp[0] = array[0];
        dp.push_back(array[0]);//状态边界
        for(int i = 1;i<array.size();i++){
            dp.push_back(max(array[i],array[i]+dp[i-1]));//状态转移方程。
        }
        int k = 0;
        for(int j =1;j<dp.size();j++)
            if(dp[j]>dp[k]){
                k = j;
            }
        return dp[k];
    
    }
};
```

